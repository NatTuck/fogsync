
Encrypted File Trie
~~~~~~~~~~~~~~~~~~~

EFT stores a directory tree and its contents as a bunch of indistinguishable
encrypted blocks.

Security goals:
 * Someone with access to the stored blocks should be unable to determine much
   about the stored file contents and structure.
 * Even if someone is monitoring changes to the stored blocks, they should only
   be able to determine the approximate size of each change.

Performance goals:
  The following operations should be fast:
    * Extracting a file or directory listing, even if the blocks are stored
      remotely.
    * Inserting / updating a file or directory listing.
    * Determining the sets of added and deleted blocks after any operation.

Features that would be nice:
  * Cheap snapshots.


This implementation:
  * Blocks are 16k (data) + 64 bytes (nonce & mac).
  * There are four categories of block:
    * Directory tree structure (a hash-mapped trie)
    * Data block lists (a "number trie")
    * Small data blocks (entities < ~12k)
    * Large data blocks (chunks of entities > ~12k)
  * Each block is referenced by its 32-byte SHA256 hash.
  * Each block is encrypted and authenticated with XSalsa20 + Poly1305 (NACL Secret Box)
  * Blocks are always encrypted.


Directory Tree Blocks
~~~~~~~~~~~~~~~~~~~~~

Each EFT store is has a single root block identified by its block hash. This
block is the root of a hash trie. This trie maps file system paths to entities
(directories, files, symbolic links) in the file system.

Paths are hashed with SHA256 to form the key.

The trie structure is as described below.

The following tree-specific data is stored in each table entry:
    [34,42]: Size of entity


Small Entity Blocks
~~~~~~~~~~~~~~~~~~~

If an entity is under 12k, it can be stored directly in a single data
block. The extra 4k leaves space for storing keys for the directory tree
trie.

Structure:
    [0,  4k]: Entity Metadata Header
    [4k, 16k]: Data

Entity Metadata Header:
    [0,   4]: Type (directory, file, symlink)
    [4,  12]: Size (uint64)
    [12, 20]: Mtime (uint64, nanoseconds since epoch)
    [20, 24]: Mode (0 = default, 1 = u+x)
    [24, 32]: Reserved
    [32, 64]: Hash
    [1k, 2k]: Path (4 byte length, 1020 bytes of data)
    [2k, 3k]: Last Modified By (user@host) (4 byte length, 1020 bytes data)
    [3k, 4k]: Reserved

Note that this means directories are only needed for traversals. They store
a JSON list of file names and nothing else.

Block Lists
~~~~~~~~~~~

For entities over 12k, it is nessisary to store the list of blocks that
constitute the entity. This list is stored as a trie of block numbers
to block hashes. This has the advantage of allowing reasonably efficient
random reads and writes within a file.

The key used to index the trie is a 64-bit unsigned integer in little-
endian byte order with trailing zero bytes removed. This means that the
depth of the trie will be the minimum that uniquely addresses all the
blocks of the entity.

The byte-trie structure described below is used.

In the root of the trie, the header is the Entity Metadata header.

The following tree-specific data is used in table entries.
    [34, 42]: Data block #


Large Entity Blocks:
~~~~~~~~~~~~~~~~~~~

These have data in them.



EFT On-Disk Byte Trie:
~~~~~~~~~~~~~~~~~~~~~

On-disk byte tries are used to store both Path -> Item mappings and, within
an Item, Block # -> Block mappings.

Both cases are instances of the generic problem of mapping a sequence of bytes
derived from a key to a block hash.

Each trie node has 256 entries, indexed by one byte in the hash. Entries are
48 bytes, making the total table 12k in size.

Each node in the Trie is structured as follows:

Block list node format:
    [0,   4k]: Header (Tree-specific data)
    [4k, 16k]: Table

Table entry structure:
    [0,  32]: Block hash for target or subtrie.
    [32, 33]: Entry type:
        0 = Entry
        1 = Sub-Trie
        2 = An Item
    [33, 34]: Previous key byte
    [34, 48]: Tree-specific data

In order to save disk space, multiple child nodes without conflicting
entries may be shared. This complicates both insertion and deletion, without
changing how lookups work.

On insert:

When you get a collison in a table, you'd normally just insert a new node
for that branch in the trie. Instead, we first try two other options:

 - If there is another subtrie for a different entry in the table where the
   appopriate slot is free, that subtrie is shared. Note that this means that
   any subtrie update needs to scan its parent and also update any matching
   pointers.

 - If the collison is from an item that is in a different subtrie due to
   sharing, we split out this subtrie into its own node.

On delete:

When the last entry in a table is deleted, the node should be deleted. To
do this we need to have the parent scan for references to the node.

After a delete, we try to merge this table with a non-conflicting table
in the parent. 
