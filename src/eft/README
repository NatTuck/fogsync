
Encrypted File Trie
~~~~~~~~~~~~~~~~~~~

EFT stores a directory tree and its contents as a bunch of indistinguishable
encrypted blocks.

Security goals:
 * Someone with access to the stored blocks should be unable to determine much
   about the stored file contents and structure.
 * Even if someone is monitoring changes to the stored blocks, they should only
   be able to determine the approximate size of each change.

Performance goals:
  The following operations should be fast:
    * Extracting a file or directory listing, even if the blocks are stored
      remotely.
    * Inserting / updating a file or directory listing.
    * Determining the sets of added and deleted blocks after any operation.

Features that would be nice:
  * Cheap snapshots.


This implementation:
  * Blocks are 16k (data) + 64 bytes (nonce & mac).
  * There are four categories of block:
    * Directory tree structure (a hash-mapped trie)
    * Data block lists (a "number trie")
    * Small data blocks (entities < ~12k)
    * Large data blocks (chunks of entities > ~12k)
  * Each block is referenced by its 32-byte SHA256 hash.
  * Each block is encrypted and authenticated with XSalsa20 + Poly1305 (NACL Secret Box)
  * Blocks are always encrypted.


Directory Tree Blocks
~~~~~~~~~~~~~~~~~~~~~

Each EFT store is has a single root block identified by its block hash. This
block is the root of a hash trie. This trie maps file system paths to entities
(directories, files, symbolic links) in the file system.

Paths are hashed with SHA256 to form the key.

The trie structure is as described below.

The following tree-specific data is stored in each table entry:
    [34,42]: Size of entity


Small Entity Blocks
~~~~~~~~~~~~~~~~~~~

If an entity is under 12k, it can be stored directly in a single data
block. The extra 4k leaves space for storing keys for the directory tree
trie.

Structure:
    [0,   2k]: Entity Metadata Header
    [2k,  4k]: Reserved
    [4k, 16k]: Data

Entity Metadata Header:
    [0,   4]: Type (directory, file, symlink)
    [4,  12]: Size (uint64)
    [12, 20]: Mtime (uint64, nanoseconds since epoch)
    [20, 24]: Mode (0 = default, 1 = u+x)
    [24, 32]: Reserved
    [32, 64]: Hash
    [512,1k]: Last Modified By (user@host) (4 byte length, 508 bytes data)
    [1k, 2k]: Path (4 byte length, 1020 bytes of data)

Note that this means directories are only needed for traversals. They store
a JSON list of file names and nothing else.

Block Lists
~~~~~~~~~~~

For entities over 12k, it is nessisary to store the list of blocks that
constitute the entity. This list is stored as a trie of block numbers
to block hashes. This has the advantage of allowing reasonably efficient
random reads and writes within a file.

The key used to index the trie is a 64-bit unsigned integer in little-
endian byte order with trailing zero bytes removed. This means that the
depth of the trie will be the minimum that uniquely addresses all the
blocks of the entity.

The byte-trie structure described below is used.

In the root of the trie, the header is the Entity Metadata header.

The following tree-specific data is used in table entries.
    [34, 42]: Data block # (stored as a little-endian uint64)


Large Entity Blocks:
~~~~~~~~~~~~~~~~~~~

These have data in them.



EFT On-Disk Byte Trie:
~~~~~~~~~~~~~~~~~~~~~

On-disk byte tries are used to store both Path -> Item mappings and, within
an Item, Block # -> Block mappings.

Both cases are instances of the generic problem of mapping a sequence of bytes
derived from a key to a block hash.

Each trie node has 256 entries, indexed by one byte in the hash. Entries are
48 bytes, making the total table 12k in size.

Each node in the Trie is structured as follows:

Block list node format:
    [0,   2k]: Header (Tree-specific data)
    [2k,3.5k]: Reserved
    [3.5k,4k]: List of overflow tables
    [4k, 16k]: Table

Table entry structure:
    [0,  32]: Block hash for target or subtrie.
    [32, 33]: Entry type:
        0 = Entry
        1 = Sub-Trie
        2 = An Item
    [34, 42]: (Partial) key
    [42, 48]: Tree-specific data


TODO: Implement overflow tables

In order to save disk space, each table has 16 overflow tables. These are used
to store entries without creating subtries.

When a collision occurs, the first four bits of the next key byte are used to
select an overflow table from the list. This overflow table is like a regular
trie node, except the items in it are kept in no specific order.

Once an overflow table is full, its entries are re-inserted into subtries as
usual. 
